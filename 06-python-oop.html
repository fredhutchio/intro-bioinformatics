<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">

<title>Introduction to Bioinformatics</title>

<meta name="description" content="Introduction to Bioinformatics">

<!-- Disabled for now - embeds HTML in author string -->
<!--  <meta name="author" content="Lesson 6 - Object Oriented Programming with Python" /> -->

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
  <link rel="stylesheet" href="src/theme/csmall.css" id="theme">


<!-- For syntax highlighting -->
  <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">


<!-- If the query includes 'print-pdf', use the PDF print sheet -->
<script>
  document.write( '<link rel="stylesheet" href="reveal.js/css/print/' +
    ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) +
    '.css" type="text/css" media="print">' );
</script>

<!--[if lt IE 9]>
<script src="reveal.js/lib/js/html5shiv.js"></script>
<![endif]-->

<!-- Note escaped dollars -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
  </script>

</head>

<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">

<section>
<h1>Introduction to Bioinformatics</h1>
<h3>Lesson 6 - Object Oriented Programming with Python</h3>
<p>
<h4></h4>
</p>
</section>


<section id="object-oriented-programming" class="level1">
<h1>Object Oriented Programming</h1>
<section id="oop-yeah-you-know-me" class="level2">
<h2>OOP: yeah, you know me…</h2>
<p><em>Wherein from simple elements we construct towering monuments</em></p>
</section>
</section>
<section id="what-well-cover-today" class="level1">
<h1>What we’ll cover today</h1>
<ul>
<li>What <em>is</em> OOP?</li>
<li>Why do we <em>care</em> about it?</li>
<li>How do you <em>use</em> it?</li>
<li>How do you <em>do</em> it?</li>
<li>How much <em>should</em> you do it?</li>
</ul>
</section>
<section id="what-is-oop" class="level1">
<h1>What <em>is</em> OOP?</h1>
<p>OOP is a way of writing programs by bundling data and functionality into <em>objects</em>.</p>
</section>
<section id="why-do-we-have-oop" class="level1">
<h1>Why do we <em>have</em> OOP?</h1>
<p>Large programs can be difficult to analyze; Keeping track of how data and computations relate to the <em>state</em> of the program is challenging.</p>
<p>OOP is a way of organizing data and computation with the goal of making it easier to conceptualize and deconstruct the system as a whole.</p>
</section>
<section id="the-objects-in-oop" class="level1">
<h1>The Objects in OOP</h1>
<p>Objects are entities which bundle data together with computations we think of as the objects “behaviors”. The data is organized into <em>attributes</em> and the computations into <em>methods</em>.</p>
<p>Objects are typically mutable: Methods can modify (the <em>state</em> of) the attributes of the objects on which they’re called.</p>
</section>
<section id="classes" class="level1">
<h1>Classes</h1>
<p><em>Classes</em> are a way of defining the shape and behavior of objects. In class based OOP, we say that objects are <em>instances</em> of a class.</p>
<p>Example: the string <code>&quot;cat&quot;</code> is an instance of the class <code>str</code> (surprise!).</p>
<p>Class based OOP is the most common form in modern languages, and indeed, python’s OOP is class based.</p>
</section>
<section id="thats-it-in-a-nutshell" class="level1">
<h1>That’s it in a nutshell</h1>
<p>Any questions?</p>
</section>
<section id="how-do-i-use-others-oop" class="level1">
<h1>How do I <em>use</em> other’s OOP</h1>
<p>This is the easy part.</p>
<p>You can <em>consume</em> OOP data and functionality without having to structure your <em>own</em> code using these techniques.</p>
</section>
<section id="a-pertinent-example" class="level1">
<h1>A pertinent example</h1>
<p>Let’s look at the Biopython library (this should be accessible as long as you’ve loaded your python modules).</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># First import the namespace/module</span>
<span class="im">import</span> Bio.SeqIO <span class="im">as</span> SeqIO

<span class="co"># Next, create a sequence parser, specifying file and format</span>
seqrecords <span class="op">=</span> SeqIO.parse(<span class="st">&quot;data/sfv.fasta&quot;</span>, <span class="st">&quot;fasta&quot;</span>)

<span class="co"># Now let&#39;s inspect things a bit (bonus: intro to generators!)</span>
seqrecords
<span class="co"># You can use the `next` method to get the &quot;next&quot; thing from a generator.</span>
seqrecords.<span class="bu">next</span>()
seqrecords.<span class="bu">next</span>()</code></pre></div>
</section>
<section id="lets-look-at-one-of-these-seqrecords-in-more-detail" class="level1">
<h1>Let’s look at one of these <code>seqrecords</code> in more detail</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># More investigating</span>
seqrecord <span class="op">=</span> seqrecords.<span class="bu">next</span>()
seqrecord
<span class="bu">type</span>(seqrecord)</code></pre></div>
</section>
<section id="attributes" class="level1">
<h1>Attributes</h1>
<p>Objects have <em>attributes</em>. You can see what attributes an object has with <code>dir(object)</code>, and access them with <code>object.attribute_name</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">dir</span>(seqrecord)
seqrecord.name</code></pre></div>
</section>
<section id="lets-look-at-the-seqrecords-seq" class="level1">
<h1>Let’s look at the seqrecord’s <code>seq</code></h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Here&#39;s where the actual &quot;sequence&quot; is</span>
seqrecord.seq
s <span class="op">=</span> seqrecord.seq
<span class="bu">type</span>(s)
<span class="bu">dir</span>(s)</code></pre></div>
<p>So an attribute of an object can be another object. It’s objects all the way down!</p>
</section>
<section id="separation-of-concerns" class="level1">
<h1>Separation of Concerns</h1>
<p>One of the things OO encourages us to do is <em>separate concerns</em>; Classes and objects naturally do this..</p>
<p>A <code>SeqRecord</code> is concerned with the abstract <em>record</em> of a sequence; name, id, description, etc. The <code>Seq</code> is concerned with the <em>actual</em> nucleotide sequence. An instance of <code>SeqRecord</code> will have a <code>seq</code> attribute pointing to a <code>Seq</code> instance.</p>
</section>
<section id="attributes-are-open" class="level1">
<h1>Attributes are open</h1>
<p>We can add our own attributes to an object.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s.canhaz_catgifs <span class="op">=</span> <span class="va">True</span>
<span class="bu">print</span> s.canhaz_catgifs</code></pre></div>
<p>This is an open system.</p>
</section>
<section id="attributes-can-be-functions" class="level1">
<h1>Attributes can be functions</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s.transcribe
<span class="co"># &lt;bound method Seq.transcribe of Seq(...)&gt;</span>

<span class="co"># You can call these functions just like normal functions (appending `(...)`)</span>
s.transcribe()

<span class="co"># Compare with</span>
<span class="im">from</span> Bio.Seq <span class="im">import</span> Seq
Seq.transcribe
<span class="co"># &lt;unbound method Seq.transcribe&gt;</span>
Seq.transcribe(s)</code></pre></div>
<p>We call functions bound to objects <em>methods</em>. Methods describe the “behavior” of objects.</p>
</section>
<section id="let-this-sink-in" class="level1">
<h1>Let this sink in…</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># as a function</span>
Seq.transcribe(s)
<span class="co"># as a method</span>
s.transcribe()

xs <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]
<span class="co"># as a function</span>
<span class="bu">list</span>.append(xs, <span class="dv">4</span>)
<span class="co"># as a method</span>
xs.append(<span class="dv">4</span>)</code></pre></div>
<p>In a class, methods are attributes pointing to simple functions. Objects have attributes pointing to copies of these functions where the first argument is bound to the object in question.</p>
</section>
<section id="using-constructors" class="level1">
<h1>Using constructors</h1>
<p>We got this object from SeqIO, but we can also construct objects using <em>constructors</em>.</p>
<p>By default, classes act as constructors for their objects when called as a function.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">Seq(<span class="st">&quot;AGCT&quot;</span>)</code></pre></div>
</section>
<section id="thats-it-for-using-oop" class="level1">
<h1>That’s it for <em>using</em> OOP</h1>
<ul>
<li>Construct objects using constructors</li>
<li>Access object attributes
<ul>
<li><code>object.attributename</code></li>
</ul></li>
<li>Call methods on objects
<ul>
<li>methods are just functions bound to objects as attributes of those objects</li>
<li><code>object.method(arguments)</code></li>
</ul></li>
<li>Classes act as containers for the unbound methods associated with objects</li>
</ul>
<p>Any Questions?</p>
</section>
<section id="how-do-i-do-oop" class="level1">
<h1>How do I <em>do</em> OOP?</h1>
<p>A simple class, modeling data we saw last week:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Specify the name of the class, and inherit from object</span>
<span class="kw">class</span> Person(<span class="bu">object</span>):
    <span class="co"># This defines the constructor function</span>
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, age, occupation):
        <span class="co"># assign attributes passed through constructor</span>
        <span class="va">self</span>.name <span class="op">=</span> name
        <span class="va">self</span>.age <span class="op">=</span> age
        <span class="va">self</span>.occupation <span class="op">=</span> occupation

p <span class="op">=</span> Person(<span class="st">&quot;Bob Jones&quot;</span>, <span class="dv">42</span>, <span class="st">&quot;haxxor&quot;</span>)
<span class="bu">print</span> p</code></pre></div>
<p>(Note: 2 underscores (<code>_</code>) on either side of <code>init</code>)</p>
</section>
<section id="what-about-the-functionality-bit" class="level1">
<h1>What about the functionality bit</h1>
<p>Suppose we add email (this is pretend code &amp; won’t run):</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> email

<span class="kw">class</span> Person(<span class="bu">object</span>):
    <span class="co"># add email to constructor</span>
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, age, occ, email):
        <span class="va">self</span>.name <span class="op">=</span> name
        <span class="va">self</span>.age <span class="op">=</span> age
        <span class="va">self</span>.occupation <span class="op">=</span> occ
        <span class="va">self</span>.email <span class="op">=</span> email
    <span class="co"># adding a method looks like defining a function</span>
    <span class="kw">def</span> notify_via_email(<span class="va">self</span>, message):
        email.send(<span class="va">self</span>.email, message)

p <span class="op">=</span> Person(<span class="st">&quot;Bob Jones&quot;</span>, <span class="dv">42</span>, <span class="st">&quot;haxxor&quot;</span>, <span class="st">&quot;bob@jon.es&quot;</span>)
p.notify_via_email(<span class="st">&quot;your cat was found&quot;</span>)</code></pre></div>
</section>
<section id="some-things-about-what-just-happened" class="level1">
<h1>Some things about what just happened</h1>
<p>(And how this all works)</p>
<ul>
<li>When we define class <code>Person</code>, we get a <em>constructor</em> function named <code>Person</code> that returns an <em>instance</em> of class <code>Person</code>.</li>
<li>When this function is called, a blank object gets created, and the <code>__init__</code> function is called with <code>self</code> bound to the new object. This function <em>initializes</em> the object.</li>
<li>Other methods follow the same pattern; We get a <code>Person.notify_via_email</code> function, and every instance <code>p</code> of <code>Person</code> gets a <code>notify_via_email</code> attribute set to a copy of this function with the first argument bound to <code>p</code>.</li>
</ul>
</section>
<section id="lets-contrast-this-with-non-oop" class="level1">
<h1>Let’s contrast this with non-OOP</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> email

<span class="kw">def</span> notify_via_email(person, message):
    email.send(person[<span class="st">&quot;email&quot;</span>], message)

<span class="co"># This is just another way of creating a dictionary</span>
p <span class="op">=</span> <span class="bu">dict</span>(name<span class="op">=</span><span class="st">&quot;Bob Jones&quot;</span>, age<span class="op">=</span><span class="dv">42</span>,
        occupation<span class="op">=</span><span class="st">&quot;haxxor&quot;</span>, email<span class="op">=</span><span class="st">&quot;bob@jon.es&quot;</span>)
notify_via_email(person, <span class="st">&quot;your cat was found&quot;</span>)</code></pre></div>
<!--Would have to come up with a similar example like this if I want to switch to SeqRecord right off the bat-->
<p>Shorter, but it’s less clear in <code>notify_via_email</code> what valid input is. Classes make this patent/explicit.</p>
</section>
<section id="what-if-a-company-also-has-an-email" class="level1">
<h1>What if a company also has an email?</h1>
<!--It'll be really hard to capture this moral moving to SeqRecord right away-->
<p>OOP: Have to write a separate method in the <code>Company</code> class. (There are other ways around this, but they’re a bit of work).</p>
<p>Non-OOP: As long as the <code>company</code> dictionary has an <code>&quot;email&quot;</code> key/value pair, the function will still work.</p>
<p>Moral of the story: Structure can come at the cost of flexibility.</p>
</section>
<section id="but-python-is-cool" class="level1">
<h1>But python is cool!</h1>
<p>Methods are just attributes pointing to functions.</p>
<p>The attrs in an object mirror <code>o.__dict__</code>, so you can treat objects like they’re dictionaries!</p>
</section>
<section id="pretend-biopython-didnt-exist" class="level1">
<h1>Pretend Biopython didn’t exist</h1>
<p>Let’s create it.</p>
</section>
<section id="setting-up-our-editing-environment" class="level1">
<h1>Setting up our editing environment</h1>
<p>Close whatever else you were working on and/or open a new tmux-window with <code>Ctrl-a c</code>, then</p>
<pre><code>cd ~/bioinfclass
vim scripts/seqs.py</code></pre>
</section>
<section id="copying-and-pasting" class="level1">
<h1>Copying and pasting</h1>
<p>By default, vim autoindents whatever we type into the terminal. This is great for writing code, but it can mess things up on copy/paste.</p>
<p><em>Some</em> terminals/vim installations can tell when you are pasting text and will automatically turn off auto-indent. But if you find that your indentation is off when you paste things, first run <code>:set paste</code> from command mode before pasting to turn on paste-mode (thereby turning off autoindent), then afterwards run <code>:set nopaste</code> to turn autoindent back on.</p>
</section>
<section id="empty-lines-in-repl-vs-scripts" class="level1">
<h1>Empty lines in REPL vs scripts</h1>
<p>The following breaks in a REPL, but is ok in a script.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">if</span> something:
    do_stuff()

<span class="cf">else</span>:
    do_something_else()</code></pre></div>
<p>Keep this in mind when copying pasting code.</p>
</section>
<section id="redefining-seqrecord" class="level1">
<h1>Redefining SeqRecord</h1>
<p>Add the following to our <code>scripts/seqs.py</code> file.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> SeqRecord(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, seq):
        <span class="va">self</span>.name <span class="op">=</span> name
        <span class="va">self</span>.seq <span class="op">=</span> seq

s <span class="op">=</span> SeqRecord(<span class="st">&quot;MBG234Gag1&quot;</span>, <span class="st">&quot;AGCTGTCGGTAAGTCGAGT&quot;</span>)
<span class="bu">print</span> s.name
<span class="bu">print</span> s.seq</code></pre></div>
</section>
<section id="testing-our-code" class="level1">
<h1>Testing our code</h1>
<p>With python, I like to be able to test my scripts as I write them using bash.</p>
<p>Open a new tmux pane using <code>Ctrl-a |</code>. Then run the following in the bash shell:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># First make sure we&#39;re in the right directory</span>
<span class="bu">cd</span> ~/bioinfclass

<span class="co"># Run the script file we just created</span>
<span class="ex">python</span> scripts/seqs.py</code></pre></div>
<p>What do you see?</p>
</section>
<section id="now-lets-add-some-functionality" class="level1">
<h1>Now let’s add some functionality</h1>
<p>In <code>scripts/seqs.py</code>, add <code>fasta_string</code> method so things look like:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> SeqRecord(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, seq):
        <span class="va">self</span>.name <span class="op">=</span> name
        <span class="va">self</span>.seq <span class="op">=</span> seq

    <span class="kw">def</span> fasta_string(<span class="va">self</span>):
        string_rep <span class="op">=</span> <span class="st">&quot;&gt;&quot;</span> <span class="op">+</span> <span class="va">self</span>.name <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        string_rep <span class="op">+=</span> <span class="va">self</span>.seq <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        <span class="cf">return</span> string_rep

s <span class="op">=</span> SeqRecord(<span class="st">&quot;MBG234Gag1&quot;</span>, <span class="st">&quot;AGCTGTCGGTAAGTCGAGT&quot;</span>)
<span class="co"># test out our new method</span>
<span class="bu">print</span> s.fasta_string()</code></pre></div>
</section>
<section id="making-the-seq-more-robust" class="level1">
<h1>Making the <code>seq</code> more robust</h1>
<section id="section" class="level2">
<h2></h2>
<p>Suppose we want to add more functionality to the <code>seq</code> attribute? Add the following <em>before</em> our <code>SeqRecord</code> class:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Create Seq as a &quot;subclass&quot; of str</span>
<span class="kw">class</span> Seq(<span class="bu">str</span>):
    <span class="co"># If not adding any methods, must explicitly &quot;pass&quot;</span>
    <span class="cf">pass</span>

s <span class="op">=</span> Seq(<span class="st">&quot;ACGT&quot;</span>)
<span class="bu">print</span> s</code></pre></div>
<p>As a <em>subclass</em> of <code>str</code>, <code>Seq</code> will behave exactly like a string, except where we override or add behavior.</p>
</section>
<section id="the-whole-file" class="level2">
<h2>The whole file</h2>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Create Seq as a &quot;subclass&quot; of str</span>
<span class="kw">class</span> Seq(<span class="bu">str</span>):
    <span class="co"># If not adding any methods, must explicitly &quot;pass&quot;</span>
    <span class="cf">pass</span>

s <span class="op">=</span> Seq(<span class="st">&quot;ACGT&quot;</span>)
<span class="bu">print</span> s

<span class="kw">class</span> SeqRecord(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, seq):
        <span class="va">self</span>.name <span class="op">=</span> name
        <span class="va">self</span>.seq <span class="op">=</span> seq

    <span class="kw">def</span> fasta_string(<span class="va">self</span>):
        string_rep <span class="op">=</span> <span class="st">&quot;&gt;&quot;</span> <span class="op">+</span> <span class="va">self</span>.name <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        string_rep <span class="op">+=</span> <span class="va">self</span>.seq <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        <span class="cf">return</span> string_rep

s <span class="op">=</span> SeqRecord(<span class="st">&quot;MBG234Gag1&quot;</span>, <span class="st">&quot;AGCTGTCGGTAAGTCGAGT&quot;</span>)
<span class="co"># test out our new method</span>
<span class="bu">print</span> s.fasta_string()</code></pre></div>
</section>
</section>
<section id="adding-functionality-to-seq" class="level1">
<h1>Adding functionality to <code>Seq</code></h1>
<section id="section-1" class="level2">
<h2></h2>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="bu">str</span>):
    <span class="co"># A class attribute, available to all seqs</span>
    complements <span class="op">=</span> <span class="bu">dict</span>(A<span class="op">=</span><span class="st">&quot;T&quot;</span>, T<span class="op">=</span><span class="st">&quot;A&quot;</span>, C<span class="op">=</span><span class="st">&quot;G&quot;</span>, G<span class="op">=</span><span class="st">&quot;C&quot;</span>)
    <span class="kw">def</span> complement(<span class="va">self</span>):
        <span class="co"># Create list of complemented characters</span>
        bps <span class="op">=</span> [<span class="va">self</span>.complements[bp] <span class="cf">for</span> bp <span class="kw">in</span> <span class="va">self</span>]
        <span class="co"># Join characters together, and Seq them</span>
        joined_bps <span class="op">=</span> <span class="st">&quot;&quot;</span>.join(bps)
        <span class="cf">return</span> Seq(joined_bps)

s <span class="op">=</span> Seq(<span class="st">&quot;ACGT&quot;</span>)
<span class="bu">print</span> s.complement()</code></pre></div>
</section>
<section id="the-whole-file-1" class="level2">
<h2>The whole file</h2>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="bu">str</span>):
    <span class="co"># A class attribute, available to all seqs</span>
    complements <span class="op">=</span> <span class="bu">dict</span>(A<span class="op">=</span><span class="st">&quot;T&quot;</span>, T<span class="op">=</span><span class="st">&quot;A&quot;</span>, C<span class="op">=</span><span class="st">&quot;G&quot;</span>, G<span class="op">=</span><span class="st">&quot;C&quot;</span>)
    <span class="kw">def</span> complement(<span class="va">self</span>):
        <span class="co"># Create list of complemented characters</span>
        bps <span class="op">=</span> [<span class="va">self</span>.complements[bp] <span class="cf">for</span> bp <span class="kw">in</span> <span class="va">self</span>]
        <span class="co"># Join characters together, and Seq them</span>
        joined_bps <span class="op">=</span> <span class="st">&quot;&quot;</span>.join(bps)
        <span class="cf">return</span> Seq(joined_bps)

s <span class="op">=</span> Seq(<span class="st">&quot;ACGT&quot;</span>)
<span class="bu">print</span> s.complement()

<span class="kw">class</span> SeqRecord(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, seq):
        <span class="va">self</span>.name <span class="op">=</span> name
        <span class="va">self</span>.seq <span class="op">=</span> seq

    <span class="kw">def</span> fasta_string(<span class="va">self</span>):
        string_rep <span class="op">=</span> <span class="st">&quot;&gt;&quot;</span> <span class="op">+</span> <span class="va">self</span>.name <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        string_rep <span class="op">+=</span> <span class="va">self</span>.seq <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        <span class="cf">return</span> string_rep

s <span class="op">=</span> SeqRecord(<span class="st">&quot;MBG234Gag1&quot;</span>, <span class="st">&quot;AGCTGTCGGTAAGTCGAGT&quot;</span>)
<span class="co"># test out our new method</span>
<span class="bu">print</span> s.fasta_string()</code></pre></div>
</section>
</section>
<section id="note-the-class-attribute" class="level1">
<h1>Note the <em>class attribute</em></h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># The class and instances both get this attribute</span>
<span class="bu">print</span> Seq.complements
<span class="bu">print</span> s.complements</code></pre></div>
<p>Note: <code>complements</code> would frequently be called a <em>class attribute</em>, since this data lives in the class. The codecademy course calls them <em>member variables</em>, which is a more general term you don’t hear in Python as often.</p>
</section>
<section id="what-about-rna-vs-dna" class="level1">
<h1>What about RNA vs DNA?</h1>
<section id="section-2" class="level2">
<h2></h2>
<p>We can solve this by further <em>subclassing</em> <code>Seq</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="bu">str</span>):
    <span class="co"># Same method as before...</span>
    <span class="kw">def</span> complement(<span class="va">self</span>):
        bps <span class="op">=</span> [<span class="va">self</span>.complements[x] <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>]
        joined_bps <span class="op">=</span> <span class="st">&quot;&quot;</span>.join(bps)
        <span class="cf">return</span> Seq(joined_bps)

<span class="co"># But we move the class variable into subclasses</span>
<span class="kw">class</span> DNASeq(Seq):
    complements <span class="op">=</span> <span class="bu">dict</span>(A<span class="op">=</span><span class="st">&quot;T&quot;</span>, T<span class="op">=</span><span class="st">&quot;A&quot;</span>, C<span class="op">=</span><span class="st">&quot;G&quot;</span>, G<span class="op">=</span><span class="st">&quot;C&quot;</span>)

<span class="kw">class</span> RNASeq(Seq):
    complements <span class="op">=</span> <span class="bu">dict</span>(A<span class="op">=</span><span class="st">&quot;U&quot;</span>, U<span class="op">=</span><span class="st">&quot;A&quot;</span>, C<span class="op">=</span><span class="st">&quot;G&quot;</span>, G<span class="op">=</span><span class="st">&quot;C&quot;</span>)</code></pre></div>
</section>
<section id="the-whole-file-2" class="level2">
<h2>The whole file</h2>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="bu">str</span>):
    <span class="co"># A class attribute, available to all seqs</span>
    <span class="kw">def</span> complement(<span class="va">self</span>):
        bps <span class="op">=</span> [<span class="va">self</span>.complements[x] <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>]
        joined_bps <span class="op">=</span> <span class="st">&quot;&quot;</span>.join(bps)
        <span class="cf">return</span> Seq(joined_bps)

<span class="kw">class</span> DNASeq(Seq):
    complements <span class="op">=</span> <span class="bu">dict</span>(A<span class="op">=</span><span class="st">&quot;T&quot;</span>, T<span class="op">=</span><span class="st">&quot;A&quot;</span>, C<span class="op">=</span><span class="st">&quot;G&quot;</span>, G<span class="op">=</span><span class="st">&quot;C&quot;</span>)

<span class="kw">class</span> RNASeq(Seq):
    complements <span class="op">=</span> <span class="bu">dict</span>(A<span class="op">=</span><span class="st">&quot;U&quot;</span>, U<span class="op">=</span><span class="st">&quot;A&quot;</span>, C<span class="op">=</span><span class="st">&quot;G&quot;</span>, G<span class="op">=</span><span class="st">&quot;C&quot;</span>)

s <span class="op">=</span> Seq(<span class="st">&quot;ACGT&quot;</span>)
<span class="bu">print</span> s.complement()

<span class="kw">class</span> SeqRecord(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, seq):
        <span class="va">self</span>.name <span class="op">=</span> name
        <span class="va">self</span>.seq <span class="op">=</span> seq

    <span class="kw">def</span> fasta_string(<span class="va">self</span>):
        string_rep <span class="op">=</span> <span class="st">&quot;&gt;&quot;</span> <span class="op">+</span> <span class="va">self</span>.name <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        string_rep <span class="op">+=</span> <span class="va">self</span>.seq <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        <span class="cf">return</span> string_rep

s <span class="op">=</span> SeqRecord(<span class="st">&quot;MBG234Gag1&quot;</span>, <span class="st">&quot;AGCTGTCGGTAAGTCGAGT&quot;</span>)
<span class="co"># test out our new method</span>
<span class="bu">print</span> s.fasta_string()</code></pre></div>
</section>
</section>
<section id="testing-our-subclasses" class="level1">
<h1>Testing our subclasses</h1>
<section id="section-3" class="level2">
<h2></h2>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Testing out our new classes</span>
s <span class="op">=</span> DNASeq(<span class="st">&quot;ACTG&quot;</span>)
<span class="bu">print</span> s.complement()
s <span class="op">=</span> RNASeq(<span class="st">&quot;ACUG&quot;</span>)
<span class="bu">print</span> s.complement()

<span class="co"># Does our old class work by itself any more?</span>
s <span class="op">=</span> Seq(<span class="st">&quot;ACTG&quot;</span>)
<span class="bu">print</span> s.complement()</code></pre></div>
</section>
<section id="the-whole-file-3" class="level2">
<h2>The whole file</h2>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="bu">str</span>):
    <span class="co"># A class attribute, available to all seqs</span>
    <span class="kw">def</span> complement(<span class="va">self</span>):
        bps <span class="op">=</span> [<span class="va">self</span>.complements[x] <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>]
        joined_bps <span class="op">=</span> <span class="st">&quot;&quot;</span>.join(bps)
        <span class="cf">return</span> Seq(joined_bps)

<span class="kw">class</span> DNASeq(Seq):
    complements <span class="op">=</span> <span class="bu">dict</span>(A<span class="op">=</span><span class="st">&quot;T&quot;</span>, T<span class="op">=</span><span class="st">&quot;A&quot;</span>, C<span class="op">=</span><span class="st">&quot;G&quot;</span>, G<span class="op">=</span><span class="st">&quot;C&quot;</span>)

<span class="kw">class</span> RNASeq(Seq):
    complements <span class="op">=</span> <span class="bu">dict</span>(A<span class="op">=</span><span class="st">&quot;U&quot;</span>, U<span class="op">=</span><span class="st">&quot;A&quot;</span>, C<span class="op">=</span><span class="st">&quot;G&quot;</span>, G<span class="op">=</span><span class="st">&quot;C&quot;</span>)

<span class="co"># Testing out our new classes</span>
s <span class="op">=</span> DNASeq(<span class="st">&quot;ACTG&quot;</span>)
<span class="bu">print</span> s.complement()
s <span class="op">=</span> RNASeq(<span class="st">&quot;ACUG&quot;</span>)
<span class="bu">print</span> s.complement()

<span class="co"># Does our old class work by itself any more?</span>
s <span class="op">=</span> Seq(<span class="st">&quot;ACTG&quot;</span>)
<span class="bu">print</span> s.complement()

<span class="kw">class</span> SeqRecord(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, seq):
        <span class="va">self</span>.name <span class="op">=</span> name
        <span class="va">self</span>.seq <span class="op">=</span> seq

    <span class="kw">def</span> fasta_string(<span class="va">self</span>):
        string_rep <span class="op">=</span> <span class="st">&quot;&gt;&quot;</span> <span class="op">+</span> <span class="va">self</span>.name <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        string_rep <span class="op">+=</span> <span class="va">self</span>.seq <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        <span class="cf">return</span> string_rep

s <span class="op">=</span> SeqRecord(<span class="st">&quot;MBG234Gag1&quot;</span>, <span class="st">&quot;AGCTGTCGGTAAGTCGAGT&quot;</span>)
<span class="co"># test out our new method</span>
<span class="bu">print</span> s.fasta_string()</code></pre></div>
</section>
</section>
<section id="woops-a-bug" class="level1">
<h1>Woops! A bug!</h1>
<p>When we take the complement, we get a <code>Seq</code>, but we should get either a <code>DNASeq</code> or an <code>RNASeq</code> (as appropriate)!</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> DNASeq(<span class="st">&quot;ACTG&quot;</span>)
<span class="bu">print</span> <span class="bu">type</span>(s.complement())
s <span class="op">=</span> RNASeq(<span class="st">&quot;ACUG&quot;</span>)
<span class="bu">print</span> <span class="bu">type</span>(s.complement())

<span class="co"># Now we can&#39;t take complement of the complement of an RNASeq...</span>
s.complement().complement()</code></pre></div>
<p>Try solving this later :-) (Solutions at end of slides)</p>
</section>
<section id="thats-all-well-look-at-for-doing-oop" class="level1">
<h1>That’s all we’ll look at for doing OOP</h1>
<p>Any Questions?</p>
</section>
<section id="how-hard-should-i-oop" class="level1">
<h1>How hard should I OOP?</h1>
<p>Design guidance vs flexibility</p>
</section>
<section id="the-pros-and-cons-of-oop" class="level1">
<h1>The pros and cons of OOP</h1>
<p><strong>Extreme Example:</strong> Java. Even printing “hello world” then exiting requires creating a class. All data and functionality <em>must</em> be bound to classes/objects. This can be very constraining.</p>
<p><strong>The good with OOP:</strong> Easier to conceptualize, because we can think about programs being made of things, like we do in the real world.</p>
<p><strong>The bad:</strong> Extra work, and code can become siloed and difficult to generalize or share between different parts of the program.</p>
</section>
<section id="my-recommendation" class="level1">
<h1>My recommendation</h1>
<p>OOP is strong medicine; don’t overuse it.</p>
<p>Python gives us a choice here. Use classes when they help you conceptualize complexity. Avoid when they add complexity.</p>
<p>Try starting with plain functions. If you find yourself having trouble figuring out what functions should be getting which data, consider bundling things into classes.</p>
</section>
<section id="excercises" class="level1">
<h1>Excercises</h1>
<p>(Answers at end of slides)</p>
</section>
<section id="ex-1---transcribe" class="level1">
<h1>Ex 1 - <code>transcribe</code></h1>
<p><strong>Problem</strong>: Add a <code>transcribe</code> method to the <code>DNASeq</code> class and a <code>reverse_transcribe</code> method to the <code>RNASeq</code> class.</p>
<p><br/></p>
<p>SideNote: biopython does this differently; Only <em>one</em> Seq class, and an <code>alphabet</code> attribute pointing to DNA/RNA. In this approach, calling <code>reverse_transcribe</code> on a <code>Seq</code> instance with a DNA alphabet gives an error. In contrast, with our approach <code>reverse_transcribe</code> is <em>only defined</em> if the <code>Seq</code> is an <code>RNASeq</code>.</p>
<p>Thinking through these architectural trade-offs is important in OOP.</p>
</section>
<section id="ex-2---reverse_complement" class="level1">
<h1>Ex 2 - <code>reverse_complement</code></h1>
<ul>
<li>Add a <code>reserve_complement</code> method to your <code>Seq</code> class, such that:
<ul>
<li>The method works with both <code>DNASeq</code> and <code>RNASeq</code> objects.</li>
</ul></li>
</ul>
</section>
<section id="ex-3---reverse_complement-ctnd" class="level1">
<h1>Ex 3 - <code>reverse_complement</code> (ctnd)</h1>
<ul>
<li>Add a <code>reverse_complement</code> method in your <code>SeqRecord</code> class, which returns a new seqrecord with:
<ul>
<li><code>seq</code> attribute the <code>reverse_complement</code> of the original sequence.</li>
<li>a modified <code>name</code> attribute (append <code>&quot;_rc&quot;</code> to the original name).</li>
</ul></li>
</ul>
</section>
<section id="bonus-excercise" class="level1">
<h1>Bonus Excercise</h1>
<ul>
<li>Make it so that when you create an instance of <code>SeqRecord</code>, you can just pass in a string for seq, and it will figure out whether it’s a <code>DNASeq</code> or a <code>RNASeq</code> based on whether it contains U or and T:
<ul>
<li>Should error out if it can’t tell.</li>
<li>Should still be possible to pass in an <code>RNASeq</code> or <code>DNASeq</code> directly, without it checking.</li>
</ul></li>
</ul>
</section>
<section id="bonus-excercise-2" class="level1">
<h1>Bonus Excercise 2</h1>
<p>Fix up the <code>Seq</code>, <code>RNASeq</code> and <code>DNASeq</code> class definitions so that <code>DNASeq.complement</code> returns a <code>DNASeq</code> object (similarly for <code>RNASeq</code>). Ideally:</p>
<ul>
<li>Most of the <code>complement</code> code stays in the <code>Seq</code> class definition</li>
<li>Override the <code>Seq.complement</code> definition in <code>RNASeq</code> and <code>DNASeq</code> so that the return value is casted as the correct class</li>
</ul>
<p>Hint: To solve this “ideally”, look into python’s <code>super</code> function.</p>
</section>
<section id="resources" class="level1">
<h1>Resources</h1>
<ul>
<li>See the codecademy section on classes (beware the bit on “member variables”)</li>
<li>Documentation on <code>transcbribe</code>: <a href="http://biopython.org/DIST/docs/api/Bio.Seq.Seq-class.html#transcribe" class="uri">http://biopython.org/DIST/docs/api/Bio.Seq.Seq-class.html#transcribe</a> (click the “source code” link to see the source code)</li>
</ul>
<p><a href="http://fredhutchio.github.io/intro-bioinformatics">Back to homepage</a></p>
</section>
<section id="excercise-solutions" class="level1">
<h1>Excercise solutions:</h1>
<p>Spoiler alert!</p>
</section>
<section id="ex-1" class="level1">
<h1>Ex 1</h1>
<p>First the simple solution:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> DNASeq(Seq):
    <span class="co"># ...</span>
    transcriptions <span class="op">=</span> <span class="bu">dict</span>(T<span class="op">=</span><span class="st">&quot;U&quot;</span>)
    <span class="kw">def</span> transcribe(<span class="va">self</span>):
        <span class="co"># Note use of get</span>
        bps <span class="op">=</span> [<span class="va">self</span>.transcriptions.get(bp, bp) <span class="cf">for</span> bp <span class="kw">in</span> <span class="va">self</span>]
        joined_bps <span class="op">=</span> <span class="st">&quot;&quot;</span>.join(bps)
        <span class="cf">return</span> RNASeq(joined_bps)

<span class="kw">class</span> RNASeq(Seq):
    <span class="co"># ...</span>
    transcriptions <span class="op">=</span> <span class="bu">dict</span>(U<span class="op">=</span><span class="st">&quot;T&quot;</span>)
    <span class="kw">def</span> reverse_transcribe(<span class="va">self</span>):
        bps <span class="op">=</span> [<span class="va">self</span>.transcriptions.get(bp, bp) <span class="cf">for</span> bp <span class="kw">in</span> <span class="va">self</span>]
        joined_bps <span class="op">=</span> <span class="st">&quot;&quot;</span>.join(bps)
        <span class="cf">return</span> DNASeq(joined_bps)

s <span class="op">=</span> DNASeq(<span class="st">&quot;ACGT&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Transcription of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.transcribe()

s <span class="op">=</span> RNASeq(<span class="st">&quot;ACGU&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Reverse trans of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.reverse_transcribe()</code></pre></div>
</section>
<section id="ex-1-ctnd" class="level1">
<h1>Ex 1 (ctnd)</h1>
<p>This works, but note that it’s a lot of duplicate code. We’ll see a more elegant way to solve this using <code>super</code> (see Bonus problem 2).</p>
</section>
<section id="ex-2" class="level1">
<h1>Ex 2</h1>
<p>First let’s solve this without worrying too much about the return type (just ensuring it’s a Seq).</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="bu">str</span>):
    <span class="co"># ...</span>
    <span class="kw">def</span> reverse_complement(<span class="va">self</span>):
        <span class="co"># Take the complement and reverse the bps</span>
        bps <span class="op">=</span> <span class="bu">reversed</span>(<span class="va">self</span>.complement())
        joined_bps <span class="op">=</span> <span class="st">&quot;&quot;</span>.join(bps)
        <span class="cf">return</span> Seq(joined_bps)

s <span class="op">=</span> DNASeq(<span class="st">&quot;ACGTCC&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Reverse comp of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.reverse_complement()

s <span class="op">=</span> RNASeq(<span class="st">&quot;ACGUCC&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Reverse comp of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.reverse_complement()</code></pre></div>
</section>
<section id="ex-2-ctnd" class="level1">
<h1>Ex 2 (ctnd)</h1>
<p>Note that if we felt like being more terse, we could omit all the intermediate variable assignments and just do everything in one line. You can decide for yourself what makes code most readable.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="bu">str</span>):
    <span class="co"># ...</span>
    <span class="kw">def</span> reverse_complement(<span class="va">self</span>):
        <span class="cf">return</span> Seq(<span class="st">&quot;&quot;</span>.join(<span class="bu">reversed</span>(<span class="va">self</span>.complement())))</code></pre></div>
</section>
<section id="bonus-1" class="level1">
<h1>Bonus 1</h1>
<p>First, we’ll solve this just using simple string methods.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> SeqRecord(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, seq):
        <span class="va">self</span>.name <span class="op">=</span> name
        <span class="co"># We&#39;ll assume a sequence without U or T is a DNASeq</span>
        <span class="cf">if</span> seq.count(<span class="st">&quot;T&quot;</span>) <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> seq.count(<span class="st">&quot;U&quot;</span>) <span class="op">==</span> <span class="dv">0</span>:
            seq <span class="op">=</span> DNASeq(seq)
        <span class="cf">elif</span> seq.count(<span class="st">&quot;U&quot;</span>) <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> seq.count(<span class="st">&quot;T&quot;</span>) <span class="op">==</span> <span class="dv">0</span>:
            seq <span class="op">=</span> RNASeq(seq)
        <span class="cf">else</span>:
            <span class="co"># Then we have both U and T, so fail</span>
            <span class="cf">raise</span> <span class="pp">ValueError</span>, <span class="st">&quot;Seq can&#39;t have both U and T&quot;</span>
        <span class="va">self</span>.seq <span class="op">=</span> seq

    <span class="co"># ...</span>

s <span class="op">=</span> SeqRecord(<span class="st">&quot;MBG1234&quot;</span>, <span class="st">&quot;AGTCTGATA&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Seqrecord seq type:&quot;</span>, <span class="bu">type</span>(s.seq)

s <span class="op">=</span> SeqRecord(<span class="st">&quot;MBG1234&quot;</span>, <span class="st">&quot;AGUCUGAUA&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Seqrecord seq type:&quot;</span>, <span class="bu">type</span>(s.seq)

<span class="co"># This one should fail</span>
SeqRecord(<span class="st">&quot;MBG1234&quot;</span>, <span class="st">&quot;AGTCUGATA&quot;</span>)</code></pre></div>
<p>Note that since the definition of <code>SeqRecord</code> here depends on <code>Seq</code>, you may have to move some code around so <code>Seq</code> is defined before <code>SeqRecord</code> is.</p>
</section>
<section id="bonus-1-ctnd" class="level1">
<h1>Bonus 1 (ctnd)</h1>
<p>This isn’t the best solution: Right now, only capital letters are considered. A good way to fix this would be to look into <a href="https://docs.python.org/2/howto/regex.html">regular expressions</a>.</p>
<p>There is always something to do to make your code better :-)</p>
</section>
<section id="bonus-2" class="level1">
<h1>Bonus 2</h1>
<p>The simple solution to this is to just write two methods, like we did in the solution to Ex 1. However, there is a better way.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> DNASeq(Seq):
    <span class="co"># ...</span>
    <span class="kw">def</span> complement(<span class="va">self</span>):
        <span class="co"># Here we use the superclass&#39; method</span>
        <span class="cf">return</span> DNASeq(Seq.complement(<span class="va">self</span>))

<span class="kw">class</span> RNASeq(Seq):
    <span class="co"># ...</span>
    <span class="kw">def</span> complement(<span class="va">self</span>):
        <span class="cf">return</span> RNASeq(Seq.complement(<span class="va">self</span>))

s <span class="op">=</span> DNASeq(<span class="st">&quot;ACGT&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Type of complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="bu">type</span>(s.complement())

s <span class="op">=</span> RNASeq(<span class="st">&quot;ACGU&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Type of complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="bu">type</span>(s.complement())</code></pre></div>
</section>
<section id="bonus-2-ctnd" class="level1">
<h1>Bonus 2 (ctnd)</h1>
<p>Note: In the assignment, I suggested using <code>super</code> to solve this. After looking for a good explanation of super as a reference, I found <a href="http://stackoverflow.com/a/1174118/177677">this stackoverflow post</a>, which gave me the idea to just refer to the unbound <code>Seq.complement</code> function directly. I think this is a lot easier to understand, and it accomplishes the same thing.</p>
</section>
<section id="revisiting-ex-2" class="level1">
<h1>Revisiting Ex 2</h1>
<p>We can use this <code>super</code>-like trick to fix our solution to Ex 2 as well:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> DNASeq(Seq):
    <span class="co"># ...</span>
    <span class="kw">def</span> reverse_complement(<span class="va">self</span>):
        <span class="cf">return</span> DNASeq(Seq.reverse_complement(<span class="va">self</span>))

<span class="kw">class</span> RNASeq(Seq):
    <span class="co"># ...</span>
    <span class="kw">def</span> reverse_complement(<span class="va">self</span>):
        <span class="cf">return</span> RNASeq(Seq.reverse_complement(<span class="va">self</span>))

s <span class="op">=</span> DNASeq(<span class="st">&quot;ACGTCC&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Type of reverse comp of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="bu">type</span>(s.reverse_complement()
s <span class="op">=</span> RNASeq(<span class="st">&quot;ACGUCC&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Type of reverse comp of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="bu">type</span>(s.reverse_complement()</code></pre></div>
</section>
<section id="revisiting-ex-1" class="level1">
<h1>Revisiting Ex 1</h1>
<p>Similarly, we can refactor <code>transcribe</code> and <code>reverse_transcribe</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="bu">str</span>):
    <span class="co"># ...</span>
    <span class="kw">def</span> abstract_transcribe(<span class="va">self</span>):
        bps <span class="op">=</span> [<span class="va">self</span>.transcriptions.get(bp, bp) <span class="cf">for</span> bp <span class="kw">in</span> <span class="va">self</span>]
        joined_bps <span class="op">=</span> <span class="st">&quot;&quot;</span>.join(bps)
        <span class="cf">return</span> Seq(joined_bps)


<span class="kw">class</span> DNASeq(Seq):
    <span class="co"># ...</span>
    <span class="kw">def</span> transcribe(<span class="va">self</span>):
        <span class="cf">return</span> RNASeq(Seq.abstract_transcribe(<span class="va">self</span>))


<span class="kw">class</span> RNASeq(Seq):
    <span class="co"># ...</span>
    <span class="kw">def</span> reverse_transcribe(<span class="va">self</span>):
        <span class="cf">return</span> DNASeq(Seq.abstract_transcribe(<span class="va">self</span>))</code></pre></div>
</section>
<section id="everything-all-together" class="level1">
<h1>Everything all together</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="bu">str</span>):
    <span class="kw">def</span> complement(<span class="va">self</span>):
        bps <span class="op">=</span> [<span class="va">self</span>.complements[bp] <span class="cf">for</span> bp <span class="kw">in</span> <span class="va">self</span>]
        joined_bps <span class="op">=</span> <span class="st">&quot;&quot;</span>.join(bps)
        <span class="cf">return</span> Seq(joined_bps)

    <span class="kw">def</span> reverse_complement(<span class="va">self</span>):
        <span class="cf">return</span> Seq(<span class="st">&quot;&quot;</span>.join(<span class="bu">reversed</span>(<span class="va">self</span>.complement())))

    <span class="kw">def</span> abstract_transcribe(<span class="va">self</span>):
        bps <span class="op">=</span> [<span class="va">self</span>.transcriptions.get(bp, bp) <span class="cf">for</span> bp <span class="kw">in</span> <span class="va">self</span>]
        joined_bps <span class="op">=</span> <span class="st">&quot;&quot;</span>.join(bps)
        <span class="cf">return</span> Seq(joined_bps)


<span class="kw">class</span> DNASeq(Seq):
    complements <span class="op">=</span> <span class="bu">dict</span>(A<span class="op">=</span><span class="st">&quot;T&quot;</span>, T<span class="op">=</span><span class="st">&quot;A&quot;</span>, C<span class="op">=</span><span class="st">&quot;G&quot;</span>, G<span class="op">=</span><span class="st">&quot;C&quot;</span>)
    transcriptions <span class="op">=</span> <span class="bu">dict</span>(T<span class="op">=</span><span class="st">&quot;U&quot;</span>)

    <span class="kw">def</span> complement(<span class="va">self</span>):
        <span class="cf">return</span> DNASeq(Seq.complement(<span class="va">self</span>))

    <span class="kw">def</span> reverse_complement(<span class="va">self</span>):
        <span class="cf">return</span> DNASeq(Seq.reverse_complement(<span class="va">self</span>))

    <span class="kw">def</span> transcribe(<span class="va">self</span>):
        <span class="cf">return</span> RNASeq(Seq.abstract_transcribe(<span class="va">self</span>))


<span class="kw">class</span> RNASeq(Seq):
    complements <span class="op">=</span> <span class="bu">dict</span>(A<span class="op">=</span><span class="st">&quot;U&quot;</span>, U<span class="op">=</span><span class="st">&quot;A&quot;</span>, C<span class="op">=</span><span class="st">&quot;G&quot;</span>, G<span class="op">=</span><span class="st">&quot;C&quot;</span>)
    transcriptions <span class="op">=</span> <span class="bu">dict</span>(U<span class="op">=</span><span class="st">&quot;T&quot;</span>)

    <span class="kw">def</span> complement(<span class="va">self</span>):
        <span class="cf">return</span> RNASeq(Seq.complement(<span class="va">self</span>))

    <span class="kw">def</span> reverse_complement(<span class="va">self</span>):
        <span class="cf">return</span> RNASeq(Seq.reverse_complement(<span class="va">self</span>))

    <span class="kw">def</span> reverse_transcribe(<span class="va">self</span>):
        <span class="cf">return</span> DNASeq(Seq.abstract_transcribe(<span class="va">self</span>))



<span class="kw">class</span> SeqRecord(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, seq):
        <span class="va">self</span>.name <span class="op">=</span> name
        <span class="co"># We&#39;ll assume a sequence without U or T is a DNASeq</span>
        <span class="cf">if</span> seq.count(<span class="st">&quot;T&quot;</span>) <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> seq.count(<span class="st">&quot;U&quot;</span>) <span class="op">==</span> <span class="dv">0</span>:
            seq <span class="op">=</span> DNASeq(seq)
        <span class="cf">elif</span> seq.count(<span class="st">&quot;U&quot;</span>) <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> seq.count(<span class="st">&quot;T&quot;</span>) <span class="op">==</span> <span class="dv">0</span>:
            seq <span class="op">=</span> RNASeq(seq)
        <span class="cf">else</span>:
            <span class="co"># Then we have both U and T, so fail</span>
            <span class="cf">raise</span> <span class="pp">ValueError</span>, <span class="st">&quot;Can&#39;t have a sequence with both U and T&quot;</span>
        <span class="va">self</span>.seq <span class="op">=</span> seq

    <span class="kw">def</span> fasta_string(<span class="va">self</span>):
        string <span class="op">=</span> <span class="st">&quot;&gt;&quot;</span> <span class="op">+</span> <span class="va">self</span>.name <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        string <span class="op">+=</span> <span class="va">self</span>.seq <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        <span class="cf">return</span> string



s <span class="op">=</span> DNASeq(<span class="st">&quot;ACGT&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Transcription of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.transcribe()

s <span class="op">=</span> RNASeq(<span class="st">&quot;ACGU&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Reverse transcription of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.reverse_transcribe()

<span class="bu">print</span> <span class="st">&quot;&quot;</span>


s <span class="op">=</span> DNASeq(<span class="st">&quot;ACGT&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.complement()
<span class="bu">print</span> <span class="st">&quot;Type of complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="bu">type</span>(s.complement())

s <span class="op">=</span> RNASeq(<span class="st">&quot;ACGU&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.complement()
<span class="bu">print</span> <span class="st">&quot;Type of complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="bu">type</span>(s.complement())

<span class="bu">print</span> <span class="st">&quot;&quot;</span>


s <span class="op">=</span> DNASeq(<span class="st">&quot;ACGTCC&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Reverse complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.reverse_complement()
<span class="bu">print</span> <span class="st">&quot;Type of reverse complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="bu">type</span>(s.reverse_complement())

s <span class="op">=</span> RNASeq(<span class="st">&quot;ACGUCC&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Reverse complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.reverse_complement()
<span class="bu">print</span> <span class="st">&quot;Type of reverse complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="bu">type</span>(s.reverse_complement())

<span class="bu">print</span> <span class="st">&quot;&quot;</span>


s <span class="op">=</span> SeqRecord(<span class="st">&quot;MBG1234&quot;</span>, <span class="st">&quot;AGTCTGATA&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Seqrecord seq type:&quot;</span>, <span class="bu">type</span>(s.seq)
<span class="co">#print s.fasta_string()</span>

s <span class="op">=</span> SeqRecord(<span class="st">&quot;MBG1234&quot;</span>, <span class="st">&quot;AGUCUGAUA&quot;</span>)
<span class="bu">print</span> <span class="st">&quot;Seqrecord seq type:&quot;</span>, <span class="bu">type</span>(s.seq)

s <span class="op">=</span> SeqRecord(<span class="st">&quot;MBG1234&quot;</span>, <span class="st">&quot;AGTCUGATA&quot;</span>)</code></pre></div>
</section>
<section id="this-page-left-intentionally-almost-blank" class="level1">
<h1>This page left intentionally almost blank</h1>
</section>
</div>

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.min.js"></script>

<script>
  // Full list of configuration options available here:
  // https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    controls: true,
    progress: true,
    history: true,
    center: false,
    slideNumber: true,


    rollingLinks: false,
  
  // available themes are in /css/theme
      theme: Reveal.getQueryHash().theme || 'csmall',
  
  // default/cube/page/concave/zoom/linear/fade/none
      transition: Reveal.getQueryHash().transition || 'fade',
  
  // Optional libraries used to extend on reveal.js
  dependencies: [
    { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
    { src: 'reveal.js/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
    { src: 'MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML'}
    // { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
    // { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
  });
Reveal.addEventListener( 'slidechanged', function( event ) {
    MathJax.Hub.Rerender();
} );
</script>

</body>
</html>
