<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">

<title>Introduction to Bioinformatics</title>

<meta name="description" content="Introduction to Bioinformatics">

<!-- Disabled for now - embeds HTML in author string -->
<!--  <meta name="author" content="Lesson 6 - Object Oriented Programming with Python" /> -->

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
  <link rel="stylesheet" href="src/theme/csmall.css" id="theme">


<!-- For syntax highlighting -->
  <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">


<!-- If the query includes 'print-pdf', use the PDF print sheet -->
<script>
  document.write( '<link rel="stylesheet" href="reveal.js/css/print/' +
    ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) +
    '.css" type="text/css" media="print">' );
</script>

<!--[if lt IE 9]>
<script src="reveal.js/lib/js/html5shiv.js"></script>
<![endif]-->

<!-- Note escaped dollars -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
  </script>

</head>

<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">

<section>
<h1>Introduction to Bioinformatics</h1>
<h3>Lesson 6 - Object Oriented Programming with Python</h3>
<p>
<h4></h4>
</p>
</section>


<section id="object-oriented-programming" class="level1">
<h1>Object Oriented Programming</h1>
<section id="oop-yeah-you-know-me" class="level2">
<h2>OOP: yeah, you know me…</h2>
<p><em>Wherein from simple elements we construct towering monuments</em></p>
</section>
</section>
<section id="what-well-cover-today" class="level1">
<h1>What we’ll cover today</h1>
<ul>
<li>What <em>is</em> OOP?</li>
<li>Why do we <em>care</em> about OOP?</li>
<li>How do I <em>use</em> OOP?</li>
<li>How do I <em>do</em> OOP?</li>
<li>How hard <em>should</em> I OOP?</li>
</ul>
</section>
<section id="what-is-oop" class="level1">
<h1>What is OOP?</h1>
<p>OOP is a way of writing programs which emphasizes bundling data and functionality.</p>
</section>
<section id="why-do-we-have-oop" class="level1">
<h1>Why do we have OOP?</h1>
<p>Before OOP, large programs were often difficult to analyze. It was hard to keep track of all the different data and functionality.</p>
<p>OOP is a way of organizing data and functionality such that it’s easier to conceptualize how they relate to each other. The goal is to make it easier to conceptualize the whole system.</p>
</section>
<section id="the-objects-in-oop" class="level1">
<h1>The Objects in OOP</h1>
<p>Objects are entities which bundle data and behavior related to that data. The data is organized into <em>attributes</em> and the behavior into <em>methods</em>.</p>
<p>Objects are usually mutable: Methods can modify (in place) the attributes of a given object.</p>
</section>
<section id="classes" class="level1">
<h1>Classes</h1>
<p><em>Classes</em> are a way of defining the shape and behavior of objects. In class based OOP, we say that objects are <em>instances</em> of a class.</p>
<p>Example: the string <code>&quot;cat&quot;</code> is an instance of the class <code>str</code>.</p>
<p>Class based OOP is the most common form in modern languages. In particular, python’s OOP is class based.</p>
</section>
<section id="thats-it-in-a-nutshell" class="level1">
<h1>That’s it in a nutshell</h1>
<p>Any questions?</p>
</section>
<section id="how-do-i-use-others-oop" class="level1">
<h1>How do I use other’s OOP</h1>
<p>This is the easy part.</p>
<p>Even if you don’t create your own objects/classes, you can still consume other folk’s OOP.</p>
</section>
<section id="a-pertinent-example" class="level1">
<h1>A pertinent example</h1>
<p>Let’s look at the Biopython library (this should be accessible as long as you’ve loaded your python modules).</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># First import the namespace/module</span>
<span class="ch">import</span> Bio.SeqIO <span class="ch">as</span> SeqIO

<span class="co"># Next, create a sequence parser, specifying file and format</span>
seqrecords = SeqIO.parse(<span class="st">&quot;data/sfv.fasta&quot;</span>, <span class="st">&quot;fasta&quot;</span>)

<span class="co"># Now let&#39;s inspect things a bit (bonus: intro to generators!)</span>
seqrecords
<span class="co"># You can use the `next` method to get the &quot;next&quot; thing from a generator.</span>
seqrecords.<span class="dt">next</span>()
seqrecords.<span class="dt">next</span>()</code></pre>
</section>
<section id="lets-look-at-one-of-these-seqrecords-in-more-detail" class="level1">
<h1>Let’s look at one of these <code>seqrecords</code> in more detail</h1>
<pre><code># More investigating
seqrecord = seqrecords.next()
seqrecord
type(seqrecord)</code></pre>
</section>
<section id="attributes" class="level1">
<h1>Attributes</h1>
<p>Objects have <em>attributes</em>. You can see what attributes an object has with <code>dir(object)</code>, and access them with <code>object.attribute_name</code>.</p>
<pre><code>dir(seqrecord)
seqrecord.name</code></pre>
</section>
<section id="lets-look-at-the-seqrecords-seq" class="level1">
<h1>Let’s look at the seqrecord’s <code>seq</code></h1>
<pre><code># Here&#39;s where the actual &quot;sequence&quot; is
seqrecord.seq
s = seqrecord.seq
type(s)
dir(s)</code></pre>
<p>So an attribute of an object can be another object.</p>
<p>It’s like Inception! Objects all the way down!</p>
</section>
<section id="seriously-though-separation-of-concerns" class="level1">
<h1>Seriously though… Separation of Concerns</h1>
<p>One of the things OO encourages us to do is separate concerns.</p>
<p>A <code>SeqRecord</code> is concerned with the more abstract record of a sequence; name, id, description, etc. The <code>Seq</code> is concerned with the <em>actual</em> nucleotide sequence data. An instance of <code>SeqRecord</code> will have a <code>seq</code> attribute which points to a <code>Seq</code> instance.</p>
<p>This separation of concerns is important to the main point of OOP: organizing functionality and data.</p>
</section>
<section id="attributes-can-be-functions" class="level1">
<h1>Attributes can be functions</h1>
<pre class="sourceCode python"><code class="sourceCode python">s.transcribe

<span class="co"># You can call these functions just like normal functions (appending `(...)`)</span>
s.transcribe()

<span class="co"># This returns the transcription of sequence s</span></code></pre>
<p>We call functions bound to objects <em>methods</em>. Methods describe the “behavior” of objects.</p>
</section>
<section id="thats-it-for-using-oop" class="level1">
<h1>That’s it for <em>using</em> OOP</h1>
<ul>
<li>Construct objects</li>
<li>Access object attributes
<ul>
<li><code>object.attributename</code></li>
</ul></li>
<li>Call methods on objects
<ul>
<li>methods are just functions bound to objects as attributes of those objects</li>
<li><code>object.method(arguments)</code></li>
</ul></li>
</ul>
<p>Any Questions?</p>
</section>
<section id="how-do-i-oop" class="level1">
<h1>How do <em>I</em> OOP?</h1>
<p>A simple class, modeling data we saw last week: <!--Switch over to SeqRecord right off the bat--></p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># First we specify the name of the class</span>
<span class="kw">class</span> Person(<span class="dt">object</span>):
    <span class="co"># This function gets called on new objects</span>
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, name, age, occupation):
        <span class="co"># setting up attributes</span>
        <span class="ot">self</span>.name = name
        <span class="ot">self</span>.age = age
        <span class="ot">self</span>.occupation = occupation

p = Person(<span class="st">&quot;Bob Jones&quot;</span>, <span class="dv">42</span>, <span class="st">&quot;haxxor&quot;</span>)
<span class="dt">print</span> p</code></pre>
<p>(Note 2 underscores (<code>_</code>) on either side of <code>init</code>)</p>
</section>
<section id="what-about-the-functionality-bit" class="level1">
<h1>What about the functionality bit</h1>
<p>Suppose we add email (this is pretend code &amp; won’t run):</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> email

<span class="kw">class</span> Person(<span class="dt">object</span>):
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, name, age, occ, email):
        <span class="ot">self</span>.name = name
        <span class="ot">self</span>.age = age
        <span class="ot">self</span>.occupation = occ
        <span class="ot">self</span>.email = email

    <span class="kw">def</span> notify_via_email(<span class="ot">self</span>, message):
        email.send(<span class="ot">self</span>.email, message)

p = Person(<span class="st">&quot;Bob Jones&quot;</span>, <span class="dv">42</span>, <span class="st">&quot;haxxor&quot;</span>, <span class="st">&quot;bob@jon.es&quot;</span>)
<span class="co"># Here, notify_via_email is &quot;bound&quot; to p</span>
p.notify_via_email(<span class="st">&quot;your cat was found&quot;</span>)</code></pre>
</section>
<section id="some-things-about-what-just-happened" class="level1">
<h1>Some things about what just happened</h1>
<p>(And how this all works)</p>
<ul>
<li>When we define class <code>Person</code>, we get a <em>constructor</em> function named <code>Person</code> that returns an <em>instance</em> of class <code>Person</code>.</li>
<li>When this function is called, a blank object gets created, and the <code>__init__</code> function is called with <code>self</code> bound to the new object.</li>
<li>This function <em>initializes</em> the object.</li>
<li>Other methods follow the same pattern; when we call <code>p.notify_via_email</code>, the <code>notify_via_email</code> function gets called with object <code>p</code> as the first argument.</li>
</ul>
</section>
<section id="lets-contrast-this-with-non-oop" class="level1">
<h1>Let’s contrast this with non-OOP</h1>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> email

<span class="kw">def</span> notify_via_email(person, message):
    email.send(person[<span class="st">&quot;email&quot;</span>], message)

<span class="co"># This is just another way of creating a dictionary</span>
p = <span class="dt">dict</span>(name=<span class="st">&quot;Bob Jones&quot;</span>, age=<span class="dv">42</span>,
        occupation=<span class="st">&quot;haxxor&quot;</span>, email=<span class="st">&quot;bob@jon.es&quot;</span>)
notify_via_email(person, <span class="st">&quot;your cat was found&quot;</span>)</code></pre>
<!--Would have to come up with a similar example like this if I want to switch to SeqRecord right off the bat-->
<p>Shorter, but it’s less clear in <code>notify_via_email</code> what valid input is. Classes make this patent/explicit.</p>
</section>
<section id="what-if-a-company-also-has-an-email" class="level1">
<h1>What if a company also has an email?</h1>
<!--It'll be really hard to capture this moral moving to SeqRecord right away-->
<p>OOP: Have to write a separate method in the <code>Company</code> class. (There are other ways around this, but they’re a bit of work).</p>
<p>Non-OOP: As long as the <code>company</code> dictionary has an <code>&quot;email&quot;</code> key/value pair, the function will still work.</p>
<p>Moral of the story: Structure can come at the cost of flexibility.</p>
</section>
<section id="pretend-biopython-didnt-exist" class="level1">
<h1>Pretend Biopython didn’t exist</h1>
<p>Let’s create it.</p>
</section>
<section id="setting-up-our-editing-environment" class="level1">
<h1>Setting up our editing environment</h1>
<p>Close whatever else you were working on and/or open a new tmux-window with <code>Ctrl-a c</code>, then</p>
<pre><code>cd ~/bioinfclass
nano scripts/seqs.py</code></pre>
</section>
<section id="copying-and-pasting" class="level1">
<h1>Copying and pasting</h1>
<p>When we installed our nanorc, we specified that <code>nano</code> should auto-indent whatever we type. While this is the best setting for actually coding, it messed up copy/paste.</p>
<p>To fix this, when you want to paste code in nano, press <code>Esc i</code> (let go in between). This will turn off the auto-indent until you press <code>Esc i</code> again (when you’re ready to type yourself again).</p>
</section>
<section id="redefining-seqrecord" class="level1">
<h1>Redefining SeqRecord</h1>
<p>Add the following to our <code>scripts/seqs.py</code> file.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> SeqRecord(<span class="dt">object</span>):
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, name, seq):
        <span class="ot">self</span>.name = name
        <span class="ot">self</span>.seq = seq

s = SeqRecord(<span class="st">&quot;MBG234Gag1&quot;</span>, <span class="st">&quot;AGCTGTCGGTAAGTCGAGT&quot;</span>)
<span class="dt">print</span> s.name
<span class="dt">print</span> s.seq</code></pre>
</section>
<section id="testing-our-code" class="level1">
<h1>Testing our code</h1>
<p>With python, I like to be able to test my scripts as I write them using bash.</p>
<p>Open a new tmux pane using <code>Ctrl-a |</code>. Then run the following in the bash shell:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># First make sure we&#39;re in the right directory</span>
<span class="kw">cd</span> ~/bioinfclass

<span class="co"># Run the script file we just created</span>
<span class="kw">python</span> scripts/seqs.py</code></pre>
<p>What do you see?</p>
</section>
<section id="now-lets-add-some-functionality" class="level1">
<h1>Now let’s add some functionality</h1>
<p>In <code>scripts/seqs.py</code>, add the following to the end of our class definition</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> fasta_string(<span class="ot">self</span>):
        string_rep = <span class="st">&quot;&gt;&quot;</span> + <span class="ot">self</span>.name + <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        string_rep += <span class="ot">self</span>.seq + <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        <span class="kw">return</span> string_rep</code></pre>
<p>Add some test code to the end of our file, then rerun:</p>
<pre><code>s = SeqRecord(&quot;MBG234Gag1&quot;, &quot;AGCTGTCGGTAAGTCGAGT&quot;)
print s.fasta_string()</code></pre>
</section>
<section id="making-the-seq-more-robust" class="level1">
<h1>Making the <code>seq</code> more robust</h1>
<p>Suppose we want to add more functionality to the <code>seq</code> attribute.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Here we create a &quot;subclass&quot; of str</span>
<span class="kw">class</span> Seq(<span class="dt">str</span>):
    <span class="co"># Here we default to str&#39;s init, etc</span>
    <span class="kw">pass</span>

s = Seq(<span class="st">&quot;ACGT&quot;</span>)
<span class="dt">print</span> s</code></pre>
<p>Note: We’re creating Seq as a <em>subclass</em> of str.</p>
</section>
<section id="surprise" class="level1">
<h1>Surprise!!!</h1>
<p>Python is super object oriented, and <code>str</code> is actually a class!</p>
<p>So are <code>float</code>, <code>bool</code> and <code>int</code>.</p>
<p><br/></p>
<p>Objects all the way down…</p>
</section>
<section id="adding-functionality-to-seq" class="level1">
<h1>Adding functionality to <code>Seq</code></h1>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="dt">str</span>):
    <span class="co"># A class attribute, available to all seqs</span>
    complements = <span class="dt">dict</span>(A=<span class="st">&quot;T&quot;</span>, T=<span class="st">&quot;A&quot;</span>, C=<span class="st">&quot;G&quot;</span>, G=<span class="st">&quot;C&quot;</span>)
    <span class="kw">def</span> complement(<span class="ot">self</span>):
        <span class="co"># Create list of complemented characters</span>
        bps = [<span class="ot">self</span>.complements[bp] <span class="kw">for</span> bp in <span class="ot">self</span>]
        <span class="co"># Join characters together, and Seq them</span>
        joined_bps = <span class="st">&quot;&quot;</span>.join(bps)
        <span class="kw">return</span> Seq(joined_bps)

s = Seq(<span class="st">&quot;ACGT&quot;</span>)
<span class="dt">print</span> s.complement()</code></pre>
</section>
<section id="note-the-class-attribute" class="level1">
<h1>Note the <em>class</em> attribute</h1>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># The class and instances both get this attribute</span>
<span class="dt">print</span> Seq.complements
<span class="dt">print</span> s.complements

<span class="co"># You can change it in the objects, but the class won&#39;t change</span>
s.complements = <span class="st">&quot;something else&quot;</span>
<span class="dt">print</span> s.complements
<span class="dt">print</span> Seq.complements</code></pre>
<p>Note: <code>complements</code> would frequently be called a <em>class attribute</em>, since this data lives in the class. The codecademy course calls them <em>member variables</em>, which is a more general term I don’t hear as often. The <em>instance attributes</em> we’ve seen before (like <code>seqrecord.name</code>) are also considered member variables. Usually we want to be specific about <code>instance</code> vs <code>clsss</code>.</p>
</section>
<section id="what-about-rna-vs-dna" class="level1">
<h1>What about RNA vs DNA?</h1>
<p>We can solve this using <em>subclasses</em>.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="dt">str</span>):
    <span class="co"># Same method as before...</span>
    <span class="kw">def</span> complement(<span class="ot">self</span>):
        bps = [<span class="ot">self</span>.complements[x] <span class="kw">for</span> x in <span class="ot">self</span>]
        joined_bps = <span class="st">&quot;&quot;</span>.join(bps)
        <span class="kw">return</span> Seq(joined_bps)

<span class="co"># But we move the class variable into subclasses</span>
<span class="kw">class</span> DNASeq(Seq):
    complements = <span class="dt">dict</span>(A=<span class="st">&quot;T&quot;</span>, T=<span class="st">&quot;A&quot;</span>, C=<span class="st">&quot;G&quot;</span>, G=<span class="st">&quot;C&quot;</span>)

<span class="kw">class</span> RNASeq(Seq):
    complements = <span class="dt">dict</span>(A=<span class="st">&quot;U&quot;</span>, U=<span class="st">&quot;A&quot;</span>, C=<span class="st">&quot;G&quot;</span>, G=<span class="st">&quot;C&quot;</span>)</code></pre>
</section>
<section id="testing-our-subclasses" class="level1">
<h1>Testing our subclasses</h1>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Testing out our new classes</span>
s = DNASeq(<span class="st">&quot;ACTG&quot;</span>)
<span class="dt">print</span> s.complement()
s = RNASeq(<span class="st">&quot;ACUG&quot;</span>)
<span class="dt">print</span> s.complement()

<span class="co"># Does our old class work by itself any more?</span>
s = Seq(<span class="st">&quot;ACTG&quot;</span>)
<span class="dt">print</span> s.complement()</code></pre>
</section>
<section id="woops-a-bug" class="level1">
<h1>Woops! A bug!</h1>
<p>When we take the complement, we get a <code>Seq</code>, but we should get either a <code>DNASeq</code> or an <code>RNASeq</code> (as appropriate)!</p>
<pre class="sourceCode python"><code class="sourceCode python">s = DNASeq(<span class="st">&quot;ACTG&quot;</span>)
<span class="dt">print</span> <span class="dt">type</span>(s.complement())
s = RNASeq(<span class="st">&quot;ACUG&quot;</span>)
<span class="dt">print</span> <span class="dt">type</span>(s.complement())

<span class="co"># Now we can&#39;t take complement the complement of an RNASeq...</span>
s.complement().complement()</code></pre>
<p>Try solving this for homework :-) (Solutions at end of slides)</p>
</section>
<section id="thats-all-well-look-at-for-doing-oop" class="level1">
<h1>That’s all we’ll look at for doing OOP</h1>
<p>Any Questions?</p>
</section>
<section id="how-hard-should-i-oop" class="level1">
<h1>How hard should I OOP?</h1>
<p>Your call. Choose wisely.</p>
</section>
<section id="one-choice-everything-oop-all-the-time" class="level1">
<h1>One choice: Everything OOP, all the time</h1>
<p><strong>Extreme Example:</strong> Java. Even printing “hello world” then exiting requires creating a class. All data and functionality <em>must</em> be bound to classes/objects.</p>
<p><strong>The good with OOP:</strong> Easier to conceptualize, because we can think about programs being made of things, like we do in the real world.</p>
<p><strong>The bad:</strong> Extra work, and code can become siloed and difficult to generalize or share between different parts of the program.</p>
</section>
<section id="my-recommendation" class="level1">
<h1>My recommendation</h1>
<p>OOP is strong medicine; don’t overuse it.</p>
<p>Python gives us a choice here. Use classes when they help you conceptualize complexity. Avoid when they add complexity.</p>
<p>Try starting with plain functions. If you find yourself having trouble figuring out what functions should be getting which data, consider bundling things into classes.</p>
</section>
<section id="homework-challenges" class="level1">
<h1>Homework challenges</h1>
<p>(Answers at end of slides)</p>
</section>
<section id="hw-1---transcribe" class="level1">
<h1>HW 1 - <code>transcribe</code></h1>
<p><strong>Problem</strong>: Add a <code>transcribe</code> method to the <code>DNASeq</code> class and a <code>reverse_transcribe</code> method to the <code>RNASeq</code> class.</p>
<p><br/></p>
<p>SideNote: biopython does this differently; Only <em>one</em> Seq class, and an <code>alphabet</code> attribute pointing to DNA/RNA. In this approach, calling <code>reverse_transcribe</code> on a <code>Seq</code> instance with a DNA alphabet gives an error. In contrast, with our approach <code>reverse_transcribe</code> is <em>only defined</em> if the <code>Seq</code> is an <code>RNASeq</code>.</p>
<p>Thinking through these architectural trade-offs is important in OOP.</p>
</section>
<section id="hw-2---reverse_complement" class="level1">
<h1>HW 2 - <code>reverse_complement</code></h1>
<ul>
<li>Add a <code>reserve_complement</code> method to your <code>Seq</code> class, such that:
<ul>
<li>The method works with both <code>DNASeq</code> and <code>RNASeq</code> objects.</li>
</ul></li>
</ul>
</section>
<section id="hw-3---reverse_complement-ctnd" class="level1">
<h1>HW 3 - <code>reverse_complement</code> (ctnd)</h1>
<ul>
<li>Add a <code>reverse_complement</code> method in your <code>SeqRecord</code> class, which returns a new seqrecord with:
<ul>
<li><code>seq</code> attribute the <code>reverse_complement</code> of the original sequence.</li>
<li>a modified <code>name</code> attribute (append <code>&quot;_rc&quot;</code> to the original name).</li>
</ul></li>
</ul>
</section>
<section id="bonus-hw-problem" class="level1">
<h1>Bonus HW problem</h1>
<ul>
<li>Make it so that when you create an instance of <code>SeqRecord</code>, you can just pass in a string for seq, and it will figure out whether it’s a <code>DNASeq</code> or a <code>RNASeq</code> based on whether it contains U or and T:
<ul>
<li>Should error out if it can’t tell.</li>
<li>Should still be possible to pass in an <code>RNASeq</code> or <code>DNASeq</code> directly, without it checking.</li>
</ul></li>
</ul>
</section>
<section id="bonus-hw-problem-2" class="level1">
<h1>Bonus HW problem 2</h1>
<p>Fix up the <code>Seq</code>, <code>RNASeq</code> and <code>DNASeq</code> class definitions so that <code>DNASeq.complement</code> returns a <code>DNASeq</code> object (similarly for <code>RNASeq</code>). Ideally:</p>
<ul>
<li>Most of the <code>complement</code> code stays in the <code>Seq</code> class definition</li>
<li>Override the <code>Seq.complement</code> definition in <code>RNASeq</code> and <code>DNASeq</code> so that the return value is casted as the correct class</li>
</ul>
<p>Hint: To solve this “ideally”, look into python’s <code>super</code> function.</p>
</section>
<section id="resources" class="level1">
<h1>Resources</h1>
<ul>
<li>See the codecademy section on classes (beware the bit on “member variables”)</li>
<li>Documentation on <code>transcbribe</code>: http://biopython.org/DIST/docs/api/Bio.Seq.Seq-class.html#transcribe (click the “source code” link to see the source code)</li>
</ul>
<p><a href="http://fredhutchio.github.io/intro-bioinformatics">Back to homepage</a></p>
</section>
<section id="homework-solutions" class="level1">
<h1>Homework solutions:</h1>
<p>Spoiler alert!</p>
</section>
<section id="hw-1" class="level1">
<h1>HW 1</h1>
<p>First the simple solution:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> DNASeq(Seq):
    <span class="co"># ...</span>
    transcriptions = <span class="dt">dict</span>(T=<span class="st">&quot;U&quot;</span>)
    <span class="kw">def</span> transcribe(<span class="ot">self</span>):
        <span class="co"># Note use of get</span>
        bps = [<span class="ot">self</span>.transcriptions.get(bp, bp) <span class="kw">for</span> bp in <span class="ot">self</span>]
        joined_bps = <span class="st">&quot;&quot;</span>.join(bps)
        <span class="kw">return</span> RNASeq(joined_bps)

<span class="kw">class</span> RNASeq(Seq):
    <span class="co"># ...</span>
    transcriptions = <span class="dt">dict</span>(U=<span class="st">&quot;T&quot;</span>)
    <span class="kw">def</span> reverse_transcribe(<span class="ot">self</span>):
        bps = [<span class="ot">self</span>.transcriptions.get(bp, bp) <span class="kw">for</span> bp in <span class="ot">self</span>]
        joined_bps = <span class="st">&quot;&quot;</span>.join(bps)
        <span class="kw">return</span> DNASeq(joined_bps)

s = DNASeq(<span class="st">&quot;ACGT&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Transcription of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.transcribe()

s = RNASeq(<span class="st">&quot;ACGU&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Reverse trans of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.reverse_transcribe()</code></pre>
</section>
<section id="hw-1-ctnd" class="level1">
<h1>HW 1 (ctnd)</h1>
<p>This works, but note that it’s a lot of duplicate code. We’ll see a more elegant way to solve this using <code>super</code> (see Bonus problem 2).</p>
</section>
<section id="hw-2" class="level1">
<h1>HW 2</h1>
<p>First let’s solve this without worrying too much about the return type (just ensuring it’s a Seq).</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="dt">str</span>):
    <span class="co"># ...</span>
    <span class="kw">def</span> reverse_complement(<span class="ot">self</span>):
        <span class="co"># Take the complement and reverse the bps</span>
        bps = <span class="dt">reversed</span>(<span class="ot">self</span>.complement())
        joined_bps = <span class="st">&quot;&quot;</span>.join(bps)
        <span class="kw">return</span> Seq(joined_bps)

s = DNASeq(<span class="st">&quot;ACGTCC&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Reverse comp of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.reverse_complement()

s = RNASeq(<span class="st">&quot;ACGUCC&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Reverse comp of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.reverse_complement()</code></pre>
</section>
<section id="hw-2-ctnd" class="level1">
<h1>HW 2 (ctnd)</h1>
<p>Note that if we felt like being more terse, we could omit all the intermediate variable assignments and just do everything in one line. You can decide for yourself what makes code most readable.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="dt">str</span>):
    <span class="co"># ...</span>
    <span class="kw">def</span> reverse_complement(<span class="ot">self</span>):
        <span class="kw">return</span> Seq(<span class="st">&quot;&quot;</span>.join(<span class="dt">reversed</span>(<span class="ot">self</span>.complement())))</code></pre>
</section>
<section id="bonus-1" class="level1">
<h1>Bonus 1</h1>
<p>First, we’ll solve this just using simple string methods.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> SeqRecord(<span class="dt">object</span>):
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, name, seq):
        <span class="ot">self</span>.name = name
        <span class="co"># We&#39;ll assume a sequence without U or T is a DNASeq</span>
        <span class="kw">if</span> seq.count(<span class="st">&quot;T&quot;</span>) &gt;= <span class="dv">0</span> and seq.count(<span class="st">&quot;U&quot;</span>) == <span class="dv">0</span>:
            seq = DNASeq(seq)
        <span class="kw">elif</span> seq.count(<span class="st">&quot;U&quot;</span>) &gt; <span class="dv">0</span> and seq.count(<span class="st">&quot;T&quot;</span>) == <span class="dv">0</span>:
            seq = RNASeq(seq)
        <span class="kw">else</span>:
            <span class="co"># Then we have both U and T, so fail</span>
            <span class="kw">raise</span> <span class="ot">ValueError</span>, <span class="st">&quot;Seq can&#39;t have both U and T&quot;</span>
        <span class="ot">self</span>.seq = seq

    <span class="co"># ...</span>

s = SeqRecord(<span class="st">&quot;MBG1234&quot;</span>, <span class="st">&quot;AGTCTGATA&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Seqrecord seq type:&quot;</span>, <span class="dt">type</span>(s.seq)

s = SeqRecord(<span class="st">&quot;MBG1234&quot;</span>, <span class="st">&quot;AGUCUGAUA&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Seqrecord seq type:&quot;</span>, <span class="dt">type</span>(s.seq)

<span class="co"># This one should fail</span>
SeqRecord(<span class="st">&quot;MBG1234&quot;</span>, <span class="st">&quot;AGTCUGATA&quot;</span>)</code></pre>
<p>Note that since the definition of <code>SeqRecord</code> here depends on <code>Seq</code>, you may have to move some code around so <code>Seq</code> is defined before <code>SeqRecord</code> is.</p>
</section>
<section id="bonus-1-ctnd" class="level1">
<h1>Bonus 1 (ctnd)</h1>
<p>This isn’t the best solution: Right now, only capital letters are considered. A good way to fix this would be to look into <a href="https://docs.python.org/2/howto/regex.html">regular expressions</a>.</p>
<p>There is always something to do to make your code better :-)</p>
</section>
<section id="bonus-2" class="level1">
<h1>Bonus 2</h1>
<p>The simple solution to this is to just write two methods, like we did in the solution to HW 1. However, there is a better way.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> DNASeq(Seq):
    <span class="co"># ...</span>
    <span class="kw">def</span> complement(<span class="ot">self</span>):
        <span class="co"># Here we use the superclass&#39; method</span>
        <span class="kw">return</span> DNASeq(Seq.complement(<span class="ot">self</span>))

<span class="kw">class</span> RNASeq(Seq):
    <span class="co"># ...</span>
    <span class="kw">def</span> complement(<span class="ot">self</span>):
        <span class="kw">return</span> RNASeq(Seq.complement(<span class="ot">self</span>))

s = DNASeq(<span class="st">&quot;ACGT&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Type of complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="dt">type</span>(s.complement())

s = RNASeq(<span class="st">&quot;ACGU&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Type of complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="dt">type</span>(s.complement())</code></pre>
</section>
<section id="bonus-2-ctnd" class="level1">
<h1>Bonus 2 (ctnd)</h1>
<p>Note: In the assignment, I suggested using <code>super</code> to solve this. After looking for a good explanation of super as a reference, I found <a href="http://stackoverflow.com/a/1174118/177677">this stackoverflow post</a>, which gave me the idea to just refer to the unbound <code>Seq.complement</code> function directly. I think this is a lot easier to understand, and it accomplishes the same thing.</p>
</section>
<section id="revisiting-hw-2" class="level1">
<h1>Revisiting HW 2</h1>
<p>We can use this <code>super</code>-like trick to fix our solution to HW 2 as well:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> DNASeq(Seq):
    <span class="co"># ...</span>
    <span class="kw">def</span> reverse_complement(<span class="ot">self</span>):
        <span class="kw">return</span> DNASeq(Seq.reverse_complement(<span class="ot">self</span>))

<span class="kw">class</span> RNASeq(Seq):
    <span class="co"># ...</span>
    <span class="kw">def</span> reverse_complement(<span class="ot">self</span>):
        <span class="kw">return</span> RNASeq(Seq.reverse_complement(<span class="ot">self</span>))

s = DNASeq(<span class="st">&quot;ACGTCC&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Type of reverse comp of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="dt">type</span>(s.reverse_complement()
s = RNASeq(<span class="st">&quot;ACGUCC&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Type of reverse comp of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="dt">type</span>(s.reverse_complement()</code></pre>
</section>
<section id="revisiting-hw-1" class="level1">
<h1>Revisiting HW 1</h1>
<p>Similarly, we can refactor <code>transcribe</code> and <code>reverse_transcribe</code>.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="dt">str</span>):
    <span class="co"># ...</span>
    <span class="kw">def</span> abstract_transcribe(<span class="ot">self</span>):
        bps = [<span class="ot">self</span>.transcriptions.get(bp, bp) <span class="kw">for</span> bp in <span class="ot">self</span>]
        joined_bps = <span class="st">&quot;&quot;</span>.join(bps)
        <span class="kw">return</span> Seq(joined_bps)


<span class="kw">class</span> DNASeq(Seq):
    <span class="co"># ...</span>
    <span class="kw">def</span> transcribe(<span class="ot">self</span>):
        <span class="kw">return</span> RNASeq(Seq.abstract_transcribe(<span class="ot">self</span>))


<span class="kw">class</span> RNASeq(Seq):
    <span class="co"># ...</span>
    <span class="kw">def</span> reverse_transcribe(<span class="ot">self</span>):
        <span class="kw">return</span> DNASeq(Seq.abstract_transcribe(<span class="ot">self</span>))</code></pre>
</section>
<section id="everything-all-together" class="level1">
<h1>Everything all together</h1>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Seq(<span class="dt">str</span>):
    <span class="kw">def</span> complement(<span class="ot">self</span>):
        bps = [<span class="ot">self</span>.complements[bp] <span class="kw">for</span> bp in <span class="ot">self</span>]
        joined_bps = <span class="st">&quot;&quot;</span>.join(bps)
        <span class="kw">return</span> Seq(joined_bps)

    <span class="kw">def</span> reverse_complement(<span class="ot">self</span>):
        <span class="kw">return</span> Seq(<span class="st">&quot;&quot;</span>.join(<span class="dt">reversed</span>(<span class="ot">self</span>.complement())))

    <span class="kw">def</span> abstract_transcribe(<span class="ot">self</span>):
        bps = [<span class="ot">self</span>.transcriptions.get(bp, bp) <span class="kw">for</span> bp in <span class="ot">self</span>]
        joined_bps = <span class="st">&quot;&quot;</span>.join(bps)
        <span class="kw">return</span> Seq(joined_bps)


<span class="kw">class</span> DNASeq(Seq):
    complements = <span class="dt">dict</span>(A=<span class="st">&quot;T&quot;</span>, T=<span class="st">&quot;A&quot;</span>, C=<span class="st">&quot;G&quot;</span>, G=<span class="st">&quot;C&quot;</span>)
    transcriptions = <span class="dt">dict</span>(T=<span class="st">&quot;U&quot;</span>)

    <span class="kw">def</span> complement(<span class="ot">self</span>):
        <span class="kw">return</span> DNASeq(Seq.complement(<span class="ot">self</span>))

    <span class="kw">def</span> reverse_complement(<span class="ot">self</span>):
        <span class="kw">return</span> DNASeq(Seq.reverse_complement(<span class="ot">self</span>))

    <span class="kw">def</span> transcribe(<span class="ot">self</span>):
        <span class="kw">return</span> RNASeq(Seq.abstract_transcribe(<span class="ot">self</span>))


<span class="kw">class</span> RNASeq(Seq):
    complements = <span class="dt">dict</span>(A=<span class="st">&quot;U&quot;</span>, U=<span class="st">&quot;A&quot;</span>, C=<span class="st">&quot;G&quot;</span>, G=<span class="st">&quot;C&quot;</span>)
    transcriptions = <span class="dt">dict</span>(U=<span class="st">&quot;T&quot;</span>)

    <span class="kw">def</span> complement(<span class="ot">self</span>):
        <span class="kw">return</span> RNASeq(Seq.complement(<span class="ot">self</span>))

    <span class="kw">def</span> reverse_complement(<span class="ot">self</span>):
        <span class="kw">return</span> RNASeq(Seq.reverse_complement(<span class="ot">self</span>))

    <span class="kw">def</span> reverse_transcribe(<span class="ot">self</span>):
        <span class="kw">return</span> DNASeq(Seq.abstract_transcribe(<span class="ot">self</span>))



<span class="kw">class</span> SeqRecord(<span class="dt">object</span>):
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, name, seq):
        <span class="ot">self</span>.name = name
        <span class="co"># We&#39;ll assume a sequence without U or T is a DNASeq</span>
        <span class="kw">if</span> seq.count(<span class="st">&quot;T&quot;</span>) &gt;= <span class="dv">0</span> and seq.count(<span class="st">&quot;U&quot;</span>) == <span class="dv">0</span>:
            seq = DNASeq(seq)
        <span class="kw">elif</span> seq.count(<span class="st">&quot;U&quot;</span>) &gt; <span class="dv">0</span> and seq.count(<span class="st">&quot;T&quot;</span>) == <span class="dv">0</span>:
            seq = RNASeq(seq)
        <span class="kw">else</span>:
            <span class="co"># Then we have both U and T, so fail</span>
            <span class="kw">raise</span> <span class="ot">ValueError</span>, <span class="st">&quot;Can&#39;t have a sequence with both U and T&quot;</span>
        <span class="ot">self</span>.seq = seq

    <span class="kw">def</span> fasta_string(<span class="ot">self</span>):
        string = <span class="st">&quot;&gt;&quot;</span> + <span class="ot">self</span>.name + <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        string += <span class="ot">self</span>.seq + <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
        <span class="kw">return</span> string



s = DNASeq(<span class="st">&quot;ACGT&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Transcription of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.transcribe()

s = RNASeq(<span class="st">&quot;ACGU&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Reverse transcription of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.reverse_transcribe()

<span class="dt">print</span> <span class="st">&quot;&quot;</span>


s = DNASeq(<span class="st">&quot;ACGT&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.complement()
<span class="dt">print</span> <span class="st">&quot;Type of complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="dt">type</span>(s.complement())

s = RNASeq(<span class="st">&quot;ACGU&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.complement()
<span class="dt">print</span> <span class="st">&quot;Type of complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="dt">type</span>(s.complement())

<span class="dt">print</span> <span class="st">&quot;&quot;</span>


s = DNASeq(<span class="st">&quot;ACGTCC&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Reverse complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.reverse_complement()
<span class="dt">print</span> <span class="st">&quot;Type of reverse complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="dt">type</span>(s.reverse_complement())

s = RNASeq(<span class="st">&quot;ACGUCC&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Reverse complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, s.reverse_complement()
<span class="dt">print</span> <span class="st">&quot;Type of reverse complement of&quot;</span>, s, <span class="st">&quot;is:&quot;</span>, <span class="dt">type</span>(s.reverse_complement())

<span class="dt">print</span> <span class="st">&quot;&quot;</span>


s = SeqRecord(<span class="st">&quot;MBG1234&quot;</span>, <span class="st">&quot;AGTCTGATA&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Seqrecord seq type:&quot;</span>, <span class="dt">type</span>(s.seq)
<span class="co">#print s.fasta_string()</span>

s = SeqRecord(<span class="st">&quot;MBG1234&quot;</span>, <span class="st">&quot;AGUCUGAUA&quot;</span>)
<span class="dt">print</span> <span class="st">&quot;Seqrecord seq type:&quot;</span>, <span class="dt">type</span>(s.seq)

s = SeqRecord(<span class="st">&quot;MBG1234&quot;</span>, <span class="st">&quot;AGTCUGATA&quot;</span>)</code></pre>
</section>
<section id="this-page-left-intentionally-almost-blank" class="level1">
<h1>This page left intentionally almost blank</h1>
</section>
</div>

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.min.js"></script>

<script>
  // Full list of configuration options available here:
  // https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    controls: true,
    progress: true,
    history: true,
    center: false,


    rollingLinks: false,
  
  // available themes are in /css/theme
      theme: Reveal.getQueryHash().theme || 'csmall',
  
  // default/cube/page/concave/zoom/linear/fade/none
      transition: Reveal.getQueryHash().transition || 'fade',
  
  // Optional libraries used to extend on reveal.js
  dependencies: [
    { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
    { src: 'reveal.js/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
    { src: 'MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML'}
    // { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
    // { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
  });
Reveal.addEventListener( 'slidechanged', function( event ) {
    MathJax.Hub.Rerender();
} );
</script>

</body>
</html>
