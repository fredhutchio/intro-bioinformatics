% Introduction to Bioinformatics
% Lesson 5 - Python basics


# What we'll cover today

* Basic data types: What kinds of data does python know about
* Syntax: What constitutes a valid expression
* Variables: How we keep track of and pass around data
* Control flow: How we specify the behaviour of our program
* Functions: How we package functionality


# Context & motivation


# Why/when shell scripts?

* Plumbing together existing command line programs...


# Why/when R?

* Very tabular data (`data.frame`s are great)
* Very tabular data operations (plyr, dplyr, reshape2)
* Plotting (ggplot2, shiny)
* Ready to go statistics functions


# Why/when python?

* More flexible data structures
* Better performance
* More flexible / cleaner programming models => better for algorithmic development
* Better organization for building bigger programs
* Better stream (Unix stdin/stdout) support than R


# Other languages?

There are other languages that fit some of these characteristics, but python is nice because

* It's become popular amongst the scientific community
* It's relatively simpler in design than other languages
* It's relatively quick to write (not necessarily to run)


# Python Basics

_In which we investigate the building blocks of logic_


# Firing up a python "REPL"

REPL is short for Read Evaluate Print Loop.

```
python
> print "Hello world"
```

Now you can enter in little bits of code as we go (type Ctrl-d or `exit` to get out)


# Basic data types

_The elements of logic_


# Why we want different data types

They allow us to be more expressive and careful about the things we're doing.

They let us more easily manage information, and relate it to the things in the world it represents.


# Scalar data types

* strings: `"this is a string"`
* ints: `42`
* floats: `3.14159`
* booleans: `True`


# Collection types

These are "containers" for other types of data (scalars, other collections, more complex data types...).


# Collection types

* tuples: `("Bob Jones", 42)`
    * fixed length
    * immutable (can't "change in place")
* lists: `["Bob Jones", "Jane Doe", "Ralph Nader"]`
    * variable length
    * mutable
* dictionaries: `{"name": "Bob Jones", "age": 42}`
    * variable length
    * mutable
    * arbitrary "key-value pairs"
    * no order guarantees


# More collection types...

We won't go into these as deeply, but it's worth being aware of them:

* generators:
    * "recipes" for a collection
    * generates each thing as you need it
    * good for "big data"
* sets
    * unique entries
    * no order guarantees


# Operations

_In which we manipulate and reason about objects_


# Numeric

* Addition: `3 + 4`
* Subtraction: `3 - 1`
* Multiplication: `4 * 5`
* Division: `6 / 5`
* Exponentiation: `10 ** 2`
* Modulo (remainder): `42 % 5`

You can create more complex expressions using parentheses for grouping: `(4 + 5) * 2`


# String

`+` works for strings too:

`"this" + "that"`


# Boolean

* Logical and: `True & False` or `True and True`
* Logical or: `False | True` or `False or False` (not exclusive...)


# Blurring the lines with booleans

* You can also treat `True` and `False` like ints `1` and `0`, respectively, and vice versa
* Scalars other than `0`, `""`, `False` or `None` will be treated as `True` in logical expression ("truthy")
* Empty collections will be treated as "falsey" in logical expressions, all other collections truthy


# Variables

Like in the shell, we can give things names

```
age = 42
name = "Bob Jones"
person = {"name": name, "age": age}

# We can use variables just as though they were their values
age / 4
```


# Variable name rules

* Must start with a character
* Can contain characters, numbers, and underscores (`_`); nothing else
* Standard convention is to use all lower case, with words separated by `_`

Example: `bobs_occupation = "haxxor"`


# Collection operations

We'll mostly focus on lists and dictionaries


# Lists

Writing `xs = [1, 2, 3, 4, 5, 6, 7]` defines a list `xs`.

* Concatenation: `+`
* Accessing: `xs[4]`
    * Get the 5th thing in the list
* Changing: `xs[3] = 999`
    * Change the 4th thing in the list

Note: Python has 0-based indexing.


# Dictionaries

These work similarly to lists, but the indices are (almost) whatever we want:

* Get the value: `person["name"]`
* Set the value: `person["occupation"] = "haxxor"`

Here `"occupation"` is the _key_, and `"haxxor"` is the _value_.
Together, they form a _key-value pair_.


# Dictionaries - arbitrary keys

Keys are often strings, but don't have to be:

```
crazy_hash = {4: "some string", (1,2,3): 999}

crazy_hash[4]
crazy_hash[(1,2,3)]
```

(Note: there are some things that _can't_ be used as keys, but most simple data are fine)


# Functions

_In which from our rules of logic we compose spells_


# Writing a simple function

```
def square(n):
    ans = n * n
    return ans

square(4)
```

* To get a value out of the function we must use `return`
* Python uses 4 spaces of indentation to separate what's in the function from what's not
    * In other languages, indentation is just "good practice" for readability; Python enforces it as part of the _syntax_


# Other things about functions

Functions are "first class", in that they can be passed around as data just like numbers, strings, etc.

```
def f(x):
    print x

print square
[square, "data"]
```

We'll see how this is useful later.


# Methods

In python, methods are just functions that are bound to particular objects as _attributes_ of that object.

Example: `"this".upper()`

Example2: `xs = [1, 2, 3]; xs.append(9); print xs`

You can see what methods are bound to an object `o` with `dir(o)` (example: `dir([])` shows all list methods)

(We'll learn more about how methods actually work next week)


# Control flow

_In which we gain mastery over the rules of logic_


# If statements

```
if 3 < 4:
    print "You should see this"
else:
    print "You should NOT see this!"
```

Things to note:

* We used indentation here as well to determine the structure of the statements
* We used the `<` (less than) operand, which behaves just as you'd expect, return True/False depending on the operand values


# You can have elif sections too

`elif` is a combination of an `else` and an `if`.

```
def f(n):
    if n < 5:
        print "Cond 1"
    elif n > 10:
        print "Cond 2"
    else:
        print "Cond 3"

f(3)
f(7)
f(12)
```


# For statements

Do something for every thing in a collection:

```
for n in xs:
    print "On int:", n

```


# Iterating over key-value pairs in a dictionary

Dictionaries have an `items` method that gives all of the <br/> key, value pairs. Try
```
person.items()
```

Now loop over them:
```
for k, v in person.items():
    print "key:", k, "val:", v

```


# Using `for` to build results

```
ys = []
for x in xs:
    y = square(x)
    ys.append(y)

print ys
```

This is _imperative_; we're telling the computer _how_ to build `ys`


# A better way

List comprehensions:

```
ys = [square(x) for x in xs]

print ys
```


# The functional way

When possible, it better to be _functional_. Let the computer figure out _how_ to build things, just tell it _what_ to build.

```
ys = map(square, xs)

print ys
```

Note that we're passing the function `square` as an _argument_ to the function `map`.


# Higher level concerns

_In which we begin to rise to the level of systems_


# Importing modules

```
import math

dir(math)
help(math.log)

math.log(3.14)
```

`math` is a _module_.
Modules, just like objects, have _attributes_, and these attributes are typically functions that we can use in our programs (though sometimes they're just useful data, like `math.e`).


# Namespaces

We also talk about modules as being _namespaces_.
A namespace is just a path to some data or function or module.
In this case `math` can also be thought of as a namespace.


# Installing your own packages with pip

Collections of modules are called _packages_.

The command line tool `pip` can be used to install packages:

```
pip install --user biopython
```

The `--user` flag tells pip to install things in your _local_ python lib directory.
You would only omit that if you were installing _system wide_ on your own computer.


# Beware Python 3

We're using Python 2.
Sadly Python 3 has been out for YEARS, but hardly anyone is using it.
It's rather different in a number of ways, so watch out for it.


# Resources

* Code Academy [Python course](http://www.codecademy.com/tracks/python) (I highly recommend working through as much of this as you like)
* Very clear blog post on [how python variables work](http://nedbatchelder.com/text/names.html)


